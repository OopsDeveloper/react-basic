*React란
컴포넌트들의 집합체
데이터를 State (내부상태), Props (외부로 부터 전달받은 상태) 나타내는 render가 있다.
상태가 변경될때마다 re-render 된다.
실제로 변경된 부분만 화면에 업데이트 된다.

*React Hooks
- 재사용 가능한 함수들
- use로 시작하는 함수들은 React Hooks (useState - 상태관리, useEffect - 컴포넌트 생애주기 관리 로직, useUser - 서버에서 받아온 사용자, useRef, useMemo, usecollback, usecontext...)
- 내가 원하는 것들을 재사용 가능함
- Hooks은 (함수들은) 값의 재사용이 아니라 로직의 재사용을 위한것이다.

*설치 확인
node -v, npm -v, yarn -v
corepack enable

yarn create react-app basic

안되면 npx create react-app basic


 => npm create vite@latest basic --template react


*snippets 만드는법
1.shift+contl+P를 누른다.
2.Configure User Snippets 를 클릭한다.
3.New global snippets file를 클릭한다.
4.이름 만들고 코드 삽입
{
  "reactFunction": {
    "prefix": "rfc",
    "body": "import React from 'react';\n\nexport default function ${1:${TM_FILENAME_BASE}}() {\n\treturn (\n\t\t<div>\n\t\t\t\n\t\t</div>\n\t);\n}\n\n",
    "description": "Creates a React Function component"
  },
  "reactStatelessImplicitReturn": {
    "prefix": "rsi",
    "body": "import React from 'react';\n\nexport const ${1:${TM_FILENAME_BASE}} = (props) => (\n\t\t\t$0\n\t);",
    "description": "Creates a React Function component"
  },
  "Import Module CSS": {
    "prefix": "si",
    "body": ["import styles from './$TM_FILENAME_BASE.module.css'"],
    "description": "Import PostCSS"
  },
  "ClassName": {
    "prefix": "cn",
    "body": ["className={styles.$1}"],
    "description": "Adding className"
  }
}

*컴포넌트 만들어 나갈때
공통적인 데이터는 필요하고 제일 근접한 부모 컴포넌트에 두고 
개별적으로 필요한 stats가 있다면 props로 전달

*useEffect
React에서 부수 효과(side effects) 를 처리할 때 사용하는 훅(생성,업데이트,정리)
1.컴포넌트가 처음 마운트될 때 실행 (생성 시)
→ 예: API 호출, 초기 데이터 설정, 이벤트 리스너 등록 등
2.컴포넌트가 특정 값이 변경될 때 실행 (업데이트 시)
→ 예: props나 state 값이 바뀔 때 효과를 적용해야 할 경우
3.컴포넌트가 언마운트될 때 실행 (정리 작업 필요 시)
→ 예: 이벤트 리스너 제거, 타이머 정리, WebSocket 연결 해제 등

🛠 주요 사용 패턴
1️⃣ 처음 한 번만 실행 (마운트 시)
useEffect(() => {
  console.log("컴포넌트가 처음 마운트됨!");
}, []); // 빈 배열이면 한 번만 실행

2️⃣ 특정 값이 변경될 때 실행
useEffect(() => {
  console.log(`count 값이 변경됨: ${count}`);
}, [count]); // count가 바뀔 때마다 실행

3️⃣ 정리(clean-up) 작업 필요할 때
useEffect(() => {
  const timer = setInterval(() => {
    console.log("1초마다 실행");
  }, 1000);

  return () => {
    clearInterval(timer); // 컴포넌트가 사라질 때 정리
    console.log("타이머 정리됨");
  };
}, []);
🚀 결론
컴포넌트가 처음 등록될 때 ([]) 실행하고 싶으면 빈 배열을 넣어.
특정 값이 바뀔 때 실행하고 싶으면 의존성 배열에 값을 넣어.
언마운트될 때 정리가 필요하면 return 안에 정리 코드를 넣어.


*uuid 사용법
npm install uuid
import { v4 as uuidv4 } from 'uuid'; 해서 사용

*리액트에서는 Object 내부의 값을 변경을 해도 UI상에 업데이트 되지 않는다.
객체를 만들면 객체마다 참조값이 만들어지는데
리액트는 참조값이 만들어져야지 변경이 되었다는것을 안다.
참조값이 동일한 상태에서 안에 내용을 아무리 수정해봤자 동일한 객체로 간주하여 업데이트를 하지 않는다.
그래서 새로운 참조값을 만들어야 업데이트 된다.

결론은 리액트에서 사용하는 모든 state는 불변성을 유지해야된다.
리액트에서 사용하는 상태의 객체나 배열의 내부 내용을 직접적으로 업데이트하면 안되고
변경이 발생한다면 객체나 배열의 전체적인 껍데기를 새로 만들어서 업데이트 해야한다.


*useReducer
React 상태관리하는 패턴중 하나로 상태를 업데이트 하는 방식
액션(action)을 기반으로 현재 상태를 변경하는 순수 함수를 정의하는 것
상태 업데이트 로직을 컴포넌트 바깥으로 분리하여 재사용성과 테스트 가능성을 높일 수 있다.

*Context
두 컴포넌트 상태값을 공유해야 한다면?
모든 컴포넌트들이 필요하다면
어플리케이션 전반적으로 필요한 경우
Context API를 사용할 수 있다.
언어, 테마(다크모드), 로그인 정보
빈번히 업데이트 되는 상태는 쓰지 않는다.
근접한 곳에서 사용해야된다.(우산)

*useMemo, useCallback
컴포넌트 내부에서 무거운 일을 하고 매번 호출되기를 바라지 않는다면 useMemo와 useCallback으로 처리 가능하다.

