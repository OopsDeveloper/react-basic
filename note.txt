*React란
컴포넌트들의 집합체
데이터를 State (내부상태), Props (외부로 부터 전달받은 상태) 나타내는 render가 있다.
상태가 변경될때마다 re-render 된다.
실제로 변경된 부분만 화면에 업데이트 된다.

*React Hooks
- 재사용 가능한 함수들
- use로 시작하는 함수들은 React Hooks (useState - 상태관리, useEffect - 컴포넌트 생애주기 관리 로직, useUser - 서버에서 받아온 사용자, useRef, useMemo, usecollback, usecontext...)
- 내가 원하는 것들을 재사용 가능함
- Hooks은 (함수들은) 값의 재사용이 아니라 로직의 재사용을 위한것이다.

*설치 확인
node -v, npm -v, yarn -v
corepack enable

yarn create react-app basic

안되면 npx create react-app basic


 => npm create vite@latest basic --template react


*snippets 만드는법
1.shift+contl+P를 누른다.
2.Configure User Snippets 를 클릭한다.
3.New global snippets file를 클릭한다.
4.이름 만들고 코드 삽입
{
  "reactFunction": {
    "prefix": "rfc",
    "body": "import React from 'react';\n\nexport default function ${1:${TM_FILENAME_BASE}}() {\n\treturn (\n\t\t<div>\n\t\t\t\n\t\t</div>\n\t);\n}\n\n",
    "description": "Creates a React Function component"
  },
  "reactStatelessImplicitReturn": {
    "prefix": "rsi",
    "body": "import React from 'react';\n\nexport const ${1:${TM_FILENAME_BASE}} = (props) => (\n\t\t\t$0\n\t);",
    "description": "Creates a React Function component"
  },
  "Import Module CSS": {
    "prefix": "si",
    "body": ["import styles from './$TM_FILENAME_BASE.module.css'"],
    "description": "Import PostCSS"
  },
  "ClassName": {
    "prefix": "cn",
    "body": ["className={styles.$1}"],
    "description": "Adding className"
  }
}

*컴포넌트 만들어 나갈때
공통적인 데이터는 필요하고 제일 근접한 부모 컴포넌트에 두고 
개별적으로 필요한 stats가 있다면 props로 전달

*useEffect
React에서 부수 효과(side effects) 를 처리할 때 사용하는 훅(생성,업데이트,정리)
1.컴포넌트가 처음 마운트될 때 실행 (생성 시)
→ 예: API 호출, 초기 데이터 설정, 이벤트 리스너 등록 등
2.컴포넌트가 특정 값이 변경될 때 실행 (업데이트 시)
→ 예: props나 state 값이 바뀔 때 효과를 적용해야 할 경우
3.컴포넌트가 언마운트될 때 실행 (정리 작업 필요 시)
→ 예: 이벤트 리스너 제거, 타이머 정리, WebSocket 연결 해제 등

🛠 주요 사용 패턴
1️⃣ 처음 한 번만 실행 (마운트 시)
useEffect(() => {
  console.log("컴포넌트가 처음 마운트됨!");
}, []); // 빈 배열이면 한 번만 실행

2️⃣ 특정 값이 변경될 때 실행
useEffect(() => {
  console.log(`count 값이 변경됨: ${count}`);
}, [count]); // count가 바뀔 때마다 실행

3️⃣ 정리(clean-up) 작업 필요할 때
useEffect(() => {
  const timer = setInterval(() => {
    console.log("1초마다 실행");
  }, 1000);

  return () => {
    clearInterval(timer); // 컴포넌트가 사라질 때 정리
    console.log("타이머 정리됨");
  };
}, []);
🚀 결론
컴포넌트가 처음 등록될 때 ([]) 실행하고 싶으면 빈 배열을 넣어.
특정 값이 바뀔 때 실행하고 싶으면 의존성 배열에 값을 넣어.
언마운트될 때 정리가 필요하면 return 안에 정리 코드를 넣어.


*uuid 사용법
npm install uuid
import { v4 as uuidv4 } from 'uuid'; 해서 사용